# コントロールパネルのリファクタリング設計

## 背景と課題

エディタ画面のコントロールパネル（`+control-panel.tsx`）は現在約500行のコードを含み、複数の責務を持つコンポーネントとなっている。具体的には、スライド画像の読み込みと管理、AI生成処理の制御、コスト計算と表示、候補画像の選択といった処理が単一のコンポーネント内に混在している。

この構造により、useState と useEffect が大量に並び、コードの見通しが悪い。また、状態管理のロジックとUI表示が密結合しているため、テストが困難であり、将来的な機能追加や変更時の影響範囲が予測しづらい。

最近、スライド切り替え時に前のスライドの画像が表示されるバグや、画像読み込みの遅延問題が発生した。これらは状態管理の複雑さに起因するものであり、リファクタリングの必要性を示している。

## リファクタリングの目的

コードの可読性と保守性を向上させることが第一の目的である。具体的には、各責務を明確に分離し、それぞれが独立してテスト可能な単位とすることで、将来的なバグの発生を抑え、機能追加時の変更範囲を局所化する。

マーティン・ファウラーの提唱するリファクタリング原則に従い、小さなステップで段階的に改善を進める。各ステップでは既存の動作を保証しながら構造を改善し、TypeScriptの型システムを活用してリグレッションを防ぐ。

特に重要なのは、テスト駆動でリファクタリングを進めることである。ファウラーは「リファクタリングの前提条件は、しっかりした一連のテストを持つことである」と述べている。テストがあれば、リファクタリング中に既存の動作を壊していないことを継続的に確認でき、安心してコードを改善できる。

## 設計アプローチ

### 責務の分離

コントロールパネルの機能を以下の3つの独立した責務に分離する。

**画像管理** は、オリジナル画像と生成された候補画像の読み込み、キャッシュ、そしてスライド切り替え時のクリーンアップを担当する。Object URLのライフサイクル管理が重要であり、メモリリークを防ぐために適切なクリーンアップが必要である。

**生成処理制御** は、ユーザーが入力したプロンプトに基づくAI生成のトリガー、進行状況の追跡、エラーハンドリング、そして生成結果の保存を担当する。APIキーの検証、バリデーション、アナリティクスイベントの送信など、多くの副作用を伴う処理である。

**コスト計算** は、為替レートの取得、入力トークンと出力トークン数の推定、コスト表示のフォーマットを担当する。生成処理とは独立した純粋な計算処理である。

### テスト戦略

リファクタリングを安全に進めるため、各機能に対してテストを用意する。テストフレームワークとしてvitestを採用し、Reactコンポーネントのテストには@testing-library/reactを使用する。

テストは以下の3つのレイヤーで構成される。

**ユニットテスト**は、純粋関数やユーティリティ関数の動作を検証する。コスト計算関数、フォーマット関数など、副作用を持たない関数が対象である。これらは最も書きやすく、実行も高速であるため、リファクタリングの基盤として最初に整備する。

**フックテスト**は、カスタムフックの動作を検証する。@testing-library/react-hooksを使用し、状態の変化や副作用の発生を確認する。画像読み込み、生成処理といった複雑なロジックを含むフックは、モックを活用してテストする。

**統合テスト**は、コンポーネント全体の動作を検証する。ユーザーの操作フローに沿って、プロンプト入力から生成、候補選択までの一連の流れが正しく動作することを確認する。これは最も網羅的だが、実行コストも高いため、重要なシナリオに絞って実施する。

すでにコスト計算機能については16個のユニットテストが完成しており、すべて合格している。これにより、コスト計算ロジックはリファクタリング中も安全に保たれることが保証されている。

### 段階的な移行戦略

リファクタリングは以下の段階を踏んで進める。各段階では、テストを実行して既存の動作が保たれていることを確認する。

**Phase 0: テスト基盤の構築**（完了）

vitestと@testing-library/reactをセットアップし、テスト環境を整える。まず既存の純粋関数に対してテストを書き、リファクタリングの安全網を構築する。

- vitest、@testing-library/react、happy-domのインストール
- vitest.config.tsとテストセットアップファイルの作成
- package.jsonにテストスクリプト（test、test:ui、test:coverage）を追加
- コスト計算関数のテスト作成（16テストケース、すべて合格）

この段階により、リファクタリングを安全に進めるための基盤が整った。

**Phase 1: 関数の抽出**

既存のコンポーネント内で関数を抽出し、責務ごとにコードを整理する。この段階ではファイル構造は変更せず、あくまで同一ファイル内でのリファクタリングにとどめる。

- Phase 1-1: 画像管理の関数を抽出・整理
- Phase 1-2: 生成処理の関数を抽出・整理
- Phase 1-3: コスト計算の関数を抽出・整理

各サブフェーズの完了後は、pnpm testを実行してすべてのテストが通ることを確認する。TypeScriptの型推論により、関数抽出時の誤りを早期に検出できる。

**Phase 2: カスタムフックへの移動**

整理された関数群をカスタムフックとして独立したファイルに移動する。各フックには対応するテストファイルを作成し、動作を検証する。

- Phase 2-1: 画像管理を`hooks/useSlideImages.ts`に移動、テスト作成
- Phase 2-2: コスト計算を`hooks/useCostEstimate.ts`に移動（既存テストを活用）
- Phase 2-3: 生成処理を`hooks/useSlideGeneration.ts`に移動、テスト作成

各フックは明確なインターフェースを持ち、戻り値の型を明示することで、利用側での誤用を防ぐ。フックのテストでは、モックを活用して外部依存（OPFS、Gemini API）を切り離し、ロジックの正確性を検証する。

**Phase 3: UIコンポーネントの分割**

プロンプト入力フォーム、候補画像グリッド、コスト表示といった視覚的なまとまりに基づいてコンポーネントを切り出す。

- プロンプト入力フォームコンポーネントの作成
- 候補画像グリッドコンポーネントの作成
- コスト表示コンポーネントの作成

この段階では、親コンポーネントはカスタムフックから受け取った状態と関数を子コンポーネントに渡すだけの薄い層となる。UIコンポーネントについては、重要なインタラクション（プロンプト入力、候補選択など）に対してテストを追加する。

### 各Phaseの検証方法

各Phaseの完了後は以下の検証を必ず実施する。

**自動テストの実行**では、`pnpm test --run`ですべてのテストケースが合格することを確認する。リファクタリングによって既存の動作が壊れていないことを機械的に検証する。

**型チェックとlint**では、`pnpm validate`によってTypeScriptのコンパイル、コードフォーマット、lintチェックがすべてパスすることを確認する。型エラーが発生していないことは、リファクタリングの正確性を示す重要な指標である。

**手動動作確認**では、ブラウザ上で実際にアプリケーションを操作し、主要なユーザーフローが正しく動作することを確認する。スライドの切り替え、画像の生成、候補の選択、コスト表示といった操作を一通り実行し、視覚的な問題がないか確認する。

## 期待される効果

リファクタリング後のコードは、各カスタムフックが50〜100行程度、親コンポーネントが100行程度となり、それぞれが単一の責務を持つ構造となる。これにより、新たな機能の追加や既存機能の変更時に、影響範囲が明確になる。

テストカバレッジの向上により、リグレッションバグの発生を大幅に削減できる。各カスタムフックには対応するテストが存在し、ロジックの変更時には即座に影響を検出できる。コスト計算、画像管理、生成処理といった重要な機能が自動テストで保護されることで、将来的な変更に対する安心感が得られる。

状態管理のロジックがUIから分離されることで、ロジックの変更がUIに影響を与えにくくなり、逆もまた然りである。カスタムフックは純粋なロジック層として機能し、UIコンポーネントは表示に専念する。この明確な責務分離により、コードの理解が容易になり、新しいメンバーがプロジェクトに参加した際のオンボーディングも円滑になる。

このリファクタリングは、将来的な機能拡張、例えばバッチ生成機能や生成履歴の表示機能といった追加に対して、より柔軟に対応できる構造を提供する。テスト駆動で進めることにより、リファクタリング自体の品質も担保され、マーティン・ファウラーが説く「安全なリファクタリング」を実現できる。
